/**
 * Formatting Module
 * Handles AI response formatting, rendering of markdown content,
 * code highlighting, thinking sections, and displaying search results.
 * 
 * This module centralizes all formatting-related functionality for better
 * organization and maintainability.
 * 
 * Dependencies:
 * - marked (for markdown parsing)
 * - highlight.js (for code highlighting)
 * - DOMPurify (for sanitizing HTML)
 */

/**
 * Format Blackbox AI response for better display
 * @param {string} text - The raw response text
 * @returns {string} - Formatted response text
 */
export function formatBlackboxResponse(text) {
    if (!text) return '';
    
    // Replace thinking sections with empty string since they're handled separately
    text = text.replace(/<think>[\s\S]*?<\/think>/g, '');
    
    // Replace common special tokens that might appear in responses
    text = text.replace(/\[DONE\]/g, '');
    
    // Trim any extra whitespace
    return text.trim();
}

/**
 * Render markdown content in an element
 * @param {HTMLElement} element - Element to render markdown in
 * @param {string} content - Markdown content to render
 */
export function renderMarkdownContent(element, content) {
    if (!element || !content) return;
    
    // Use DOMPurify to sanitize the HTML generated by marked
    element.innerHTML = DOMPurify.sanitize(marked.parse(content));
}

/**
 * Highlight code blocks in an element
 * @param {HTMLElement} element - Element containing code blocks
 */
export function highlightCode(element) {
    if (!element) return;
    
    // Find all pre code elements
    const codeBlocks = element.querySelectorAll('pre code');
    codeBlocks.forEach(block => {
        hljs.highlightElement(block);
    });
}

/**
 * Updates a message element with formatted content
 * @param {HTMLElement} messageElement - The message element to update
 * @param {string} content - The content to display
 */
export function updateMessageContent(messageElement, content) {
    if (!messageElement || !content) return;
    
    const messageContent = messageElement.querySelector('.message-text');
    if (!messageContent) return;
    
    renderMarkdownContent(messageContent, content);
    highlightCode(messageContent);
    scrollToBottom();
}

/**
 * Stream a response word by word to create a typing effect
 * @param {HTMLElement} messageElement - The message element to update
 * @param {string} response - The full response to stream
 */
export function streamResponse(messageElement, response) {
    if (!messageElement || !response) return;
    
    const messageContent = messageElement.querySelector('.message-text');
    if (!messageContent) return;
    
    const words = response.split(' ');
    let currentIndex = 0;
    let content = '';
    
    const interval = setInterval(() => {
        if (currentIndex < words.length) {
            content += words[currentIndex] + ' ';
            messageContent.innerHTML = DOMPurify.sanitize(marked.parse(content));
            highlightCode(messageContent);
            scrollToBottom();
            currentIndex++;
        } else {
            clearInterval(interval);
        }
    }, 50);
}

/**
 * Create a thinking section for AI responses that show reasoning
 * @param {HTMLElement} messageElement - The message element to add thinking section to
 * @returns {HTMLElement} - The created thinking section element
 */
export function createThinkingSection(messageElement) {
    if (!messageElement) return null;
    
    const thinkingSection = document.createElement('div');
    thinkingSection.className = 'thinking-section';
    thinkingSection.style.display = 'none'; // Hidden by default
    
    const thinkingHeader = document.createElement('div');
    thinkingHeader.className = 'thinking-header';
    thinkingHeader.innerHTML = '<span class="thinking-icon material-symbols-outlined">psychology</span> Thinking';
    
    const thinkingContent = document.createElement('div');
    thinkingContent.className = 'thinking-content';
    
    thinkingSection.appendChild(thinkingHeader);
    thinkingSection.appendChild(thinkingContent);
    
    // Add the thinking section after the message text
    const messageText = messageElement.querySelector('.message-text');
    if (messageText) {
        messageText.parentNode.insertBefore(thinkingSection, messageText.nextSibling);
    } else {
        messageElement.appendChild(thinkingSection);
    }
    
    return thinkingSection;
}

/**
 * Handle displaying source citations in AI responses
 * @param {HTMLElement} messageElement - The message element to add sources to
 * @param {Array} sources - Array of source objects with title, url, and snippet
 */
export function displaySourceCitations(messageElement, sources) {
    if (!messageElement || !sources || !sources.length) return;
    
    const sourcesContainer = messageElement.querySelector('.message-sources');
    if (!sourcesContainer) return;
    
    sourcesContainer.innerHTML = '';
    
    // Get the source template
    const sourceTemplate = document.getElementById('source-template');
    if (!sourceTemplate) return;
    
    sources.forEach(source => {
        const sourceElement = document.importNode(sourceTemplate.content, true);
        const titleElement = sourceElement.querySelector('.source-title');
        const urlElement = sourceElement.querySelector('.source-url');
        const snippetElement = sourceElement.querySelector('.source-snippet');
        
        titleElement.textContent = source.title || 'Untitled';
        titleElement.href = source.url;
        urlElement.textContent = source.url;
        snippetElement.textContent = source.snippet || '';
        
        sourcesContainer.appendChild(sourceElement);
    });
    
    // Make the sources container visible
    sourcesContainer.style.display = 'block';
}

/**
 * Display search results in a modal
 * @param {string} resultType - Type of results ('web' or 'x')
 * @param {Object} allSearchResults - Object containing all search results
 * @param {HTMLElement} modalElement - The modal element to show results in
 * @param {HTMLElement} containerElement - Container element inside modal for results
 */
export function showSearchResults(resultType, allSearchResults, modalElement, containerElement) {
    if (!modalElement || !containerElement) return;
    
    containerElement.innerHTML = '';
    
    const results = resultType === 'web' ? allSearchResults.web : allSearchResults.x;
    
    if (!results || results.length === 0) {
        containerElement.innerHTML = '<div class="no-results">No results available</div>';
        modalElement.style.display = 'flex';
        return;
    }
    
    // Set modal title based on result type
    const modalTitle = modalElement.querySelector('.modal-title');
    if (modalTitle) {
        modalTitle.textContent = resultType === 'web' ? 'Web Search Results' : 'X (Twitter) Results';
    }
    
    // Create HTML for the results
    if (resultType === 'web') {
        results.forEach(result => {
            const resultElement = document.createElement('div');
            resultElement.className = 'search-result web-result';
            
            resultElement.innerHTML = `
                <h3><a href="${result.url}" target="_blank" rel="noopener noreferrer">${result.title}</a></h3>
                <div class="result-url">${result.url}</div>
                <div class="result-snippet">${result.snippet || ''}</div>
            `;
            
            containerElement.appendChild(resultElement);
        });
    } else {
        // X (Twitter) results
        results.forEach(result => {
            const resultElement = document.createElement('div');
            resultElement.className = 'search-result x-result';
            
            resultElement.innerHTML = `
                <div class="x-username">@${result.username || 'user'}</div>
                <div class="x-content">${result.text || ''}</div>
                ${result.postId ? `<a href="https://twitter.com/${result.username}/status/${result.postId}" target="_blank" rel="noopener noreferrer" class="x-link">View on X</a>` : ''}
            `;
            
            containerElement.appendChild(resultElement);
        });
    }
    
    // Show the modal
    modalElement.style.display = 'flex';
}

/**
 * Scroll the messages container to the bottom
 */
function scrollToBottom() {
    const messagesContainer = document.getElementById('messages-container');
    if (messagesContainer) {
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
    }
} 